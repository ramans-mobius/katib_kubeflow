name: Generalized CNN Update Schema Row
description: Updates a row in a schema based on a mapping between column names and a JSON object.

inputs:
  - { name: schema_id, type: String, description: "The ID of the schema to update." }
  - { name: update_data_json, type: String, description: "JSON string containing the data to update." }
  - { name: mapping_json, type: String, description: "JSON string mapping column names to keys in update_data_json." }
  - { name: model_id, type: String, description: "The ID of the model to filter by." }
  - { name: execution_id, type: String, description: "The ID of the model to filter by." }
  - { name: tenant_id, type: string, description: "The ID of the tenant." }
  - { name: project_id, type: String, description: "The ID of the project." }
  - { name: architecture_type, type: String, description: "The architecture type." }
  - { name: multiple_rows_json, type: String, description: "JSON string containing a list of rows to create." }
  - { name: bearer_auth_token, type: string, description: "Bearer token for authentication." }
  - { name: domain, type: String, description: "The domain for the API endpoint." }
  - { name: float_keys_json, type: String, description: "JSON string of a list of keys to be converted to float."}

implementation:
  container:
    image: python:3.9-slim
    command:
      - sh
      - -c
      - |
        pip install requests
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import json
        import argparse
        import requests
        import random
        import time
        from requests.adapters import HTTPAdapter
        from urllib3.util.retry import Retry

        parser = argparse.ArgumentParser()
        parser.add_argument('--schema_id', type=str, required=True)
        parser.add_argument('--update_data_json', type=str, required=True)
        parser.add_argument('--mapping_json', type=str, required=True)
        parser.add_argument('--model_id', type=str, required=True)
        parser.add_argument('--execution_id', type=str, required=True)
        parser.add_argument('--tenant_id', type=str, required=True)
        parser.add_argument('--project_id', type=str, required=True)
        parser.add_argument('--architecture_type', type=str, required=True)
        parser.add_argument('--multiple_rows_json', type=str, required=True)
        parser.add_argument('--bearer_auth_token', type=str, required=True)
        parser.add_argument('--domain', type=str, required=True)
        parser.add_argument('--float_keys_json', type=str, required=False)
        args = parser.parse_args()

        with open(args.bearer_auth_token, 'r') as f:
            bearer_auth_token = f.read().strip()

        with open(args.tenant_id, 'r') as f:
            tenant_id = f.read().strip()

        print(f" Input Data ")
        print(f"update_data_json: {args.update_data_json}")
        print(f"mapping_json: {args.mapping_json}")
        
        update_data = json.loads(args.update_data_json)
        mapping = json.loads(args.mapping_json)
        
        # Handle float_keys_json safely
        if args.float_keys_json and args.float_keys_json != '-1':
            float_keys = json.loads(args.float_keys_json)
        else:
            float_keys = []

        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {bearer_auth_token}'
        }

        # Enhanced retry strategy for 500 errors
        retry_strategy = Retry(
            total=3,
            status_forcelist=[408, 500, 502, 503, 504],
            allowed_methods=["HEAD", "GET", "PUT", "POST", "DELETE", "OPTIONS", "TRACE"],
            backoff_factor=1,
            backoff_jitter=0.5
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        http = requests.Session()
        http.mount("https://", adapter)
        http.mount("http://", adapter)

        def get_working_endpoints(domain, schema_id, headers):
            list_endpoints = [
                f"{domain}/pi-entity-instances-service/v2.0/schemas/{schema_id}/instances/list",
                f"{domain}/pi-entity-instances-service/v3.0/schemas/{schema_id}/instances/list",
                f"{domain}/pi-entity-service-dbaas/v1.0/schemas/{schema_id}/instances/list"
            ]
            
            instance_endpoints = [
                f"{domain}/pi-entity-instances-service/v2.0/schemas/{schema_id}/instances",
                f"{domain}/pi-entity-instances-service/v3.0/schemas/{schema_id}/instances",
                f"{domain}/pi-entity-service-dbaas/v1.0/schemas/{schema_id}/instances"
            ]
            
            working_list_endpoint = None
            working_instance_endpoint = None
            
            # Test list endpoints
            test_payload = {
                "dbType": "TIDB",
                "ownedOnly": True,
                "filter": {}
            }
            
            for endpoint in list_endpoints:
                try:
                    print(f"Testing list endpoint: {endpoint}")
                    response = http.post(endpoint, headers=headers, json=test_payload, timeout=30)
                    if response.status_code == 200:
                        working_list_endpoint = endpoint
                        print(f"✓ List endpoint works: {endpoint}")
                        break
                    else:
                        print(f"✗ List endpoint failed with status {response.status_code}: {endpoint}")
                except Exception as e:
                    print(f"✗ List endpoint error: {endpoint} - {e}")
            
            # Test instance endpoints with GET first to avoid creating data
            for endpoint in instance_endpoints:
                try:
                    print(f"Testing instance endpoint: {endpoint}")
                    # Try a simple GET request to check if endpoint exists
                    response = http.get(endpoint, headers=headers, timeout=30)
                    if response.status_code in [200, 404]:  # 404 might mean endpoint exists but no data
                        working_instance_endpoint = endpoint
                        print(f"✓ Instance endpoint accessible: {endpoint}")
                        break
                    else:
                        print(f"✗ Instance endpoint failed with status {response.status_code}: {endpoint}")
                except Exception as e:
                    print(f"✗ Instance endpoint error: {endpoint} - {e}")
            
            return working_list_endpoint, working_instance_endpoint

        def make_retry_request(http, method, url, headers, data=None, max_retries=3):
            for attempt in range(max_retries):
                try:
                    if method.upper() == 'POST':
                        response = http.post(url, headers=headers, json=data, timeout=60)
                    elif method.upper() == 'PATCH':
                        response = http.patch(url, headers=headers, json=data, timeout=60)
                    elif method.upper() == 'PUT':
                        response = http.put(url, headers=headers, json=data, timeout=60)
                    elif method.upper() == 'GET':
                        response = http.get(url, headers=headers, timeout=60)
                    else:
                        raise ValueError(f"Unsupported method: {method}")
                    
                    if response.status_code < 400:
                        return response
                    else:
                        raise requests.exceptions.HTTPError(f"HTTP {response.status_code}: {response.text}")
                        
                except requests.exceptions.RequestException as e:
                    if attempt == max_retries - 1:
                        raise e
                    else:
                        wait_time = (2 ** attempt) + (random.random() * 0.1)
                        print(f"Request failed (attempt {attempt + 1}/{max_retries}), retrying in {wait_time:.2f}s... Error: {e}")
                        time.sleep(wait_time)

        def extract_nested_value(data, key_path):
            if isinstance(key_path, str):
                keys = key_path.split('.')
            elif isinstance(key_path, list):
                keys = key_path
            else:
                return None
                
            current = data
            for key in keys:
                if isinstance(current, dict) and key in current:
                    current = current[key]
                else:
                    return None
            return current

        # Discover working endpoints
        print("=== ENDPOINT DISCOVERY ===")
        working_list_endpoint, working_instance_endpoint = get_working_endpoints(args.domain, args.schema_id, headers)
        
        if not working_list_endpoint:
            raise Exception("No working list endpoint found")
        
        if not working_instance_endpoint:
            # If no instance endpoint found, try to derive from list endpoint
            if 'v2.0' in working_list_endpoint:
                working_instance_endpoint = working_list_endpoint.replace('/list', '')
            elif 'v3.0' in working_list_endpoint:
                working_instance_endpoint = working_list_endpoint.replace('/list', '')
            else:
                working_instance_endpoint = working_list_endpoint.replace('/list', '')
            print(f"Derived instance endpoint: {working_instance_endpoint}")

        print(f"Using list endpoint: {working_list_endpoint}")
        print(f"Using instance endpoint: {working_instance_endpoint}")

        if args.multiple_rows_json != '-1':
            # Handle multiple rows creation
            rows_to_create = json.loads(args.multiple_rows_json)
            create_payload = {"data": rows_to_create}
            
            print(f" Creating Multiple Rows ")
            print(f"Request Payload: {json.dumps(create_payload, indent=2)}")

            try:
                response = make_retry_request(http, 'POST', working_instance_endpoint, headers, create_payload)
                print("Successfully created multiple model instances.")
                print(f"Response: {response.json()}")
            except Exception as e:
                print(f"Error creating multiple model instances: {e}")
                exit(1)
        else:
            # Check if execution_id exists
            check_payload = {
                "dbType": "TIDB",
                "ownedOnly": True,
                "filter": {
                    "execution_id": args.execution_id
                }
            }
            
            print(f" Checking for Existing Row with execution_id: {args.execution_id} ")
            print(f"Request Payload: {json.dumps(check_payload, indent=2)}")

            try:
                response = make_retry_request(http, 'POST', working_list_endpoint, headers, check_payload)
                response_data = response.json()
                
                # Handle response format
                instances_found = []
                if isinstance(response_data, dict):
                    instances_found = response_data.get("content", [])
                    print(f"DEBUG: Found {len(instances_found)} instances in 'content' array")
                elif isinstance(response_data, list):
                    instances_found = response_data
                    print(f"DEBUG: Found {len(instances_found)} instances in direct list")
                else:
                    print(f"DEBUG: Unexpected response format: {type(response_data)}")
                    instances_found = []
                
                # Filter for specific execution_id
                matching_instances = [inst for inst in instances_found if inst.get('execution_id') == args.execution_id]
                print(f"DEBUG: Found {len(matching_instances)} instances with execution_id: {args.execution_id}")
                
                if matching_instances:
                    print(f" Instance Found: Updating Row ")
                    instance_to_update = matching_instances[0]
                    
                    # Build update data based on mapping
                    update_fields = {}
                    for column, source_key in mapping.items():
                        value = None
                        
                        # Handle different types of source_key mappings
                        if isinstance(source_key, list):
                            # If source_key is a list, extract nested values and create a dictionary
                            nested_data = {}
                            for key in source_key:
                                nested_value = extract_nested_value(update_data, key)
                                if nested_value is not None:
                                    nested_data[key] = nested_value
                            if nested_data:  # Only add if we found any values
                                value = nested_data
                                print(f"DEBUG: Will update {column} with nested data: {nested_data}")
                        elif isinstance(source_key, str):
                            # If source_key is a string, extract the value directly
                            value = extract_nested_value(update_data, source_key)
                            if value is not None:
                                # Handle float conversion if needed
                                if source_key in float_keys:
                                    try:
                                        value = float(value)
                                    except (ValueError, TypeError):
                                        value = str(value)
                                print(f"DEBUG: Will update {column} with {value}")
                        
                        if value is not None:
                            update_fields[column] = value
                    
                    if not update_fields:
                        print("WARNING: No valid fields to update based on mapping")
                        update_fields = {"execution_id": args.execution_id}  # Minimal update
                    
                    # Use POST for update (replace entire record)
                    try:
                        # Get the current instance data and merge with updates
                        current_data = instance_to_update.copy()
                        current_data.update(update_fields)
                        
                        # Add required fields if missing
                        if 'tenant_id' not in current_data:
                            current_data['tenant_id'] = tenant_id
                        if 'project_id' not in current_data and args.project_id != '-1':
                            current_data['project_id'] = args.project_id
                        
                        update_payload = {"data": [current_data]}
                        
                        print(f"Attempting POST update...")
                        print(f"Update Payload: {json.dumps(update_payload, indent=2)}")
                        
                        response = make_retry_request(http, 'POST', working_instance_endpoint, headers, update_payload)
                        print("Successfully updated the model instance using POST.")
                        
                    except Exception as post_error:
                        print(f"POST update failed: {post_error}")
                        print("Falling back to alternative update methods...")
                        
                        # Alternative: Try direct instance ID update if available
                        if 'id' in instance_to_update:
                            instance_id = instance_to_update['id']
                            instance_specific_endpoint = f"{working_instance_endpoint}/{instance_id}"
                            try:
                                response = make_retry_request(http, 'PUT', instance_specific_endpoint, headers, update_fields)
                                print("Successfully updated using instance-specific endpoint.")
                            except Exception as specific_error:
                                print(f"Instance-specific update also failed: {specific_error}")
                                # Last resort: try creating new record
                                print("Attempting to create new record instead...")
                                create_payload = {"data": [current_data]}
                                response = make_retry_request(http, 'POST', working_instance_endpoint, headers, create_payload)
                                print("Successfully created new record.")
                        else:
                            # Try creating new record if update fails
                            print("Attempting to create new record instead...")
                            creation_data = update_fields.copy()
                            creation_data['execution_id'] = args.execution_id
                            creation_data['tenant_id'] = tenant_id
                            if args.project_id != '-1':
                                creation_data['project_id'] = args.project_id
                            
                            create_payload = {"data": [creation_data]}
                            response = make_retry_request(http, 'POST', working_instance_endpoint, headers, create_payload)
                            print("Successfully created new record.")
                            
                else:
                    print(f" No Instance Found: Creating New Row ")
                    
                    # Build creation data
                    creation_data = {}
                    for column, source_key in mapping.items():
                        value = None
                        
                        # Handle different types of source_key mappings
                        if isinstance(source_key, list):
                            # If source_key is a list, extract nested values and create a dictionary
                            nested_data = {}
                            for key in source_key:
                                nested_value = extract_nested_value(update_data, key)
                                if nested_value is not None:
                                    nested_data[key] = nested_value
                            if nested_data:  # Only add if we found any values
                                value = nested_data
                                print(f"DEBUG: Adding {column} with nested data: {nested_data}")
                        elif isinstance(source_key, str):
                            # If source_key is a string, extract the value directly
                            value = extract_nested_value(update_data, source_key)
                            if value is not None:
                                # Handle float conversion if needed
                                if source_key in float_keys:
                                    try:
                                        value = float(value)
                                    except (ValueError, TypeError):
                                        value = str(value)
                                print(f"DEBUG: Adding {column} = {value}")
                        
                        if value is not None:
                            creation_data[column] = value
                    
                    # Add required identifiers
                    creation_data['execution_id'] = args.execution_id
                    creation_data['tenant_id'] = tenant_id
                    if args.project_id != '-1':
                        creation_data['project_id'] = args.project_id
                    if args.model_id != '-1':
                        creation_data['model_id'] = args.model_id
                    if args.architecture_type != '-1':
                        creation_data['architecture_type'] = args.architecture_type

                    create_payload = {
                        "data": [creation_data]
                    }

                    print(f"Creating new instance...")
                    print(f"Create Payload: {json.dumps(create_payload, indent=2)}")
                    
                    response = make_retry_request(http, 'POST', working_instance_endpoint, headers, create_payload)
                    print("Successfully created a new model instance.")
                    
                print(f"Response: {response.json()}")

            except Exception as e:
                print(f"Error: {e}")
                print(f"Last request details:")
                print(f"  List Endpoint: {working_list_endpoint}")
                print(f"  Instance Endpoint: {working_instance_endpoint}")
                exit(1)

    args:
      - --schema_id
      - {inputValue: schema_id}
      - --update_data_json
      - {inputValue: update_data_json}
      - --mapping_json
      - {inputValue: mapping_json}
      - --model_id
      - {inputValue: model_id}
      - --execution_id
      - {inputValue: execution_id}
      - --tenant_id
      - {inputPath: tenant_id}
      - --project_id
      - {inputValue: project_id}
      - --architecture_type
      - {inputValue: architecture_type}
      - --multiple_rows_json
      - {inputValue: multiple_rows_json}
      - --bearer_auth_token
      - {inputPath: bearer_auth_token}
      - --domain
      - {inputValue: domain}
      - --float_keys_json
      - {inputValue: float_keys_json}
